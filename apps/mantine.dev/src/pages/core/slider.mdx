import { SliderDemos } from '@docs/demos';
import { Layout } from '@/layout';
import { MDX_DATA } from '@/mdx';

export default Layout(MDX_DATA.Slider);

## Usage

<Demo data={SliderDemos.configurator} />

## Controlled

```tsx
import { useState } from 'react';
import { Slider } from '@mantine/core';

function Demo() {
  const [value, setValue] = useState(40);
  return <Slider value={value} onChange={setValue} />;
}
```

## Uncontrolled

`Slider` can be used in uncontrolled forms the same way as a native input element.
Set the `name` attribute to include the slider value in the `FormData` object on form submission.
To set the initial value in uncontrolled mode, use the `defaultValue` prop.

Example usage of uncontrolled `Slider` with `FormData`:

```tsx
import { Slider } from '@mantine/core';

function Demo() {
  return (
    <form
      onSubmit={(event) => {
        event.preventDefault();
        const formData = new FormData(event.currentTarget);
        console.log('Slider value:', formData.get('volume'));
      }}
    >
      <Slider name="volume" defaultValue={40} min={0} max={100} />
      <button type="submit">Submit</button>
    </form>
  );
}
```

## Disabled

<Demo data={SliderDemos.disabled} />

## onChangeEnd

`onChangeEnd` callback is called when the user stops dragging the slider or when the value is changed with the keyboard.
You can use it as a debounced callback to avoid too frequent updates.

<Demo data={SliderDemos.changeEnd} />

## Control label

To change label behavior and appearance, set the following props:

- `label` – formatter function, accepts value as an argument, set null to disable label, defaults to `f => f`
- `labelAlwaysOn` – if true, the label will always be displayed; by default the label is visible only when the user is dragging
- `labelTransitionProps` – props passed down to the [Transition](/core/transition) component, can be used to customize label animation

<Demo data={SliderDemos.label} />

## Min, max and step

<Demo data={SliderDemos.step} />

## Domain

By default, the `min` and `max` props define both the visual range (track display) and
the selectable range (possible values). The `domain` prop allows you to independently
control the selectable range. This is useful when you want to display a wider track
(for context) but restrict the actual selection to a subset.

In the example below, the track displays from 0 to 100 (`min`/`max`), but the thumb
can only be dragged between 20 and 80 (`domain`):

<Demo data={SliderDemos.domain} />

## Decimal values

To use `Slider` with decimal values, set `min`, `max` and `step` props:

<Demo data={SliderDemos.decimal} />

## Marks

Add any number of marks to the slider by setting the `marks` prop to an array of objects:

```tsx
const marks = [
  { value: 20 }, // -> displays mark on slider track
  { value: 40, label: '40%' }, // -> adds mark label below slider track
];
```

Note that the mark value is relative to the slider value, not width:

<Demo data={SliderDemos.marks} />

## Restrict selection to marks

Set the `restrictToMarks` prop to restrict the slider value to marks only. Note that in
this case the `step` prop is ignored:

<Demo data={SliderDemos.restrictToMarks} />

## Thumb size

<Demo data={SliderDemos.thumbSize} />

## Thumb children

<Demo data={SliderDemos.thumbChildren} />

## Scale

You can use the `scale` prop to represent the value on a different scale.

In the following demo, the value `x` represents the value `2^x`. Increasing `x` by one increases the represented value by 2 to the power of `x`.

<Demo data={SliderDemos.scale} />

## Inverted

You can invert the track with the `inverted` prop:

<Demo data={SliderDemos.inverted} />

<StylesApiSelectors component="Slider" />

<Demo data={SliderDemos.stylesApi} />

Example of using [Styles API](/styles/styles-api/) to change `Slider` styles:

<Demo data={SliderDemos.customize} />

## Vertical slider

Set `orientation="vertical"` to render the slider vertically. In vertical orientation,
the minimum value is at the bottom and the maximum value is at the top.

<Demo data={SliderDemos.vertical} />

## Hidden marks

Hidden marks allow you to snap to specific values without displaying them visually on the track.
This is useful when you want to create a "sticky" snapping behavior to certain values that
you don't want to show to the user. Use this feature together with `restrictToMarks` prop:

<Demo data={SliderDemos.hiddenMarks} />

## Build custom slider

If the `Slider` component does not meet your requirements, you can build a custom slider with the [use-move](/hooks/use-move/) hook:

<Demo data={SliderDemos.customSlider} />

## Accessibility

`Slider` component is accessible by default:

- Thumbs are focusable
- When the user uses the mouse to interact with the slider, focus is moved to the slider track; when the user presses arrows, focus is moved to the thumb
- The value can be changed with arrows with step increment/decrement

To label the component for screen readers, add labels to thumbs:

```tsx
import { Slider } from '@mantine/core';

function Demo() {
  return <Slider thumbLabel="Thumb aria-label" />;
}
```

## Keyboard interactions

<KeyboardEventsTable
  data={[
    {
      key: 'ArrowRight/ArrowUp',
      description: 'Increases the slider value by one step',
    },
    {
      key: 'ArrowLeft/ArrowDown',
      description: 'Decreases the slider value by one step',
    },
    { key: 'Home', description: 'Sets the slider value to min value' },
    { key: 'End', description: 'Sets the slider value to max value' },
  ]}
/>
