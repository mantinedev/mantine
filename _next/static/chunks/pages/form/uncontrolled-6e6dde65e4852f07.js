(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[73410],{38792:e=>{"use strict";e.exports=function e(n,t){if(n===t)return!0;if(n&&t&&"object"==typeof n&&"object"==typeof t){if(n.constructor!==t.constructor)return!1;if(Array.isArray(n)){if((o=n.length)!=t.length)return!1;for(r=o;0!=r--;)if(!e(n[r],t[r]))return!1;return!0}if(n.constructor===RegExp)return n.source===t.source&&n.flags===t.flags;if(n.valueOf!==Object.prototype.valueOf)return n.valueOf()===t.valueOf();if(n.toString!==Object.prototype.toString)return n.toString()===t.toString();if((o=(l=Object.keys(n)).length)!==Object.keys(t).length)return!1;for(r=o;0!=r--;)if(!Object.prototype.hasOwnProperty.call(t,l[r]))return!1;for(r=o;0!=r--;){var o,r,l,a=l[r];if(!e(n[a],t[a]))return!1}return!0}return n!=n&&t!=t}},36317:(e,n,t)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/form/uncontrolled",function(){return t(72457)}])},72457:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>j});var o=t(31085),r=t(71184),l=t(14041),a=t(90275),s=t(52022),m=t(93065),u=t(37905),i=t(23719),d=t(41871),c=t(28887);let f={type:"code",component:function(){let e=(0,i.m)({mode:"controlled",initialValues:{name:"",email:""},validate:{name:(0,d.J)({min:3},"Must be at least 3 characters"),email:(0,c.x)("Invalid email")}}),[n,t]=(0,l.useState)(null);return(0,o.jsxs)("form",{onSubmit:e.onSubmit(t),children:[(0,o.jsx)(a.k,{...e.getInputProps("name"),label:"Name",placeholder:"Name"}),(0,o.jsx)(a.k,{...e.getInputProps("email"),mt:"md",label:"Email",placeholder:"Email"}),(0,o.jsx)(s.$,{type:"submit",mt:"md",children:"Submit"}),(0,o.jsx)(m.E,{mt:"md",children:"Form values:"}),(0,o.jsx)(u.C,{block:!0,children:JSON.stringify(e.values,null,2)}),(0,o.jsx)(m.E,{mt:"md",children:"Submitted values:"}),(0,o.jsx)(u.C,{block:!0,children:n?JSON.stringify(n,null,2):"–"})]})},code:`
import { useState } from 'react';
import { Button, Code, Text, TextInput } from '@mantine/core';
import { hasLength, isEmail, useForm } from '@mantine/form';

function Demo() {
  const form = useForm({
    mode: 'controlled',
    initialValues: { name: '', email: '' },
    validate: {
      name: hasLength({ min: 3 }, 'Must be at least 3 characters'),
      email: isEmail('Invalid email'),
    },
  });

  const [submittedValues, setSubmittedValues] = useState<typeof form.values | null>(null);

  return (
    <form onSubmit={form.onSubmit(setSubmittedValues)}>
      <TextInput {...form.getInputProps('name')} label="Name" placeholder="Name" />
      <TextInput {...form.getInputProps('email')} mt="md" label="Email" placeholder="Email" />
      <Button type="submit" mt="md">
        Submit
      </Button>

      <Text mt="md">Form values:</Text>
      <Code block>{JSON.stringify(form.values, null, 2)}</Code>

      <Text mt="md">Submitted values:</Text>
      <Code block>{submittedValues ? JSON.stringify(submittedValues, null, 2) : '\u2013'}</Code>
    </form>
  );
}
`,maxWidth:500,centered:!0,defaultExpanded:!1};var p=t(28675),h=t(85954),x=t(38215);let g=(0,h.P)(x.XZ.formUncontrolled);function b(e){let n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components},{Demo:t}=n;return t||function(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Demo",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"controlled-mode",children:"Controlled mode"}),"\n",(0,o.jsx)(n.p,{children:"Controlled mode is the default mode of the form. In this mode, the form data is\nstored in React state and all components are rerendered when form data changes.\nControlled mode is not recommended for large forms."}),"\n",(0,o.jsx)(n.p,{children:"Example of a form with controlled mode:"}),"\n",(0,o.jsx)(t,{data:f}),"\n",(0,o.jsxs)(n.p,{children:["As you can see in the example above, ",(0,o.jsx)(n.code,{children:"form.values"})," update on every change. This\nmeans that every component that uses ",(0,o.jsx)(n.code,{children:"form.values"})," will rerender on every change."]}),"\n",(0,o.jsx)(n.h2,{id:"uncontrolled-mode",children:"Uncontrolled mode"}),"\n",(0,o.jsx)(n.p,{children:"Uncontrolled mode is an alternative mode of the form introduced in 7.8.0 release.\nIt is now the recommended mode for all forms.\nUncontrolled mode provides significant performance improvements for large forms."}),"\n",(0,o.jsxs)(n.p,{children:["With uncontrolled mode, the form data is stored in a ref instead of React state\nand ",(0,o.jsx)(n.code,{children:"form.values"})," are not updated on every change."]}),"\n",(0,o.jsx)(n.p,{children:"Example of a form with uncontrolled mode:"}),"\n",(0,o.jsx)(t,{data:p.U}),"\n",(0,o.jsxs)(n.p,{children:["As you can see in the example above, ",(0,o.jsx)(n.code,{children:"form.values"})," do not update at all."]}),"\n",(0,o.jsx)(n.h2,{id:"formgetvalues",children:"form.getValues"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"form.getValues"})," function returns current form values. It can be\nused anywhere in the component to get the current form values. It can\nbe used in both controlled and uncontrolled modes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n});\n\nform.getValues(); // { name: 'John Doe' }\n\nform.setValues({ name: 'John Smith' });\nform.getValues(); // { name: 'John Smith' }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Although ",(0,o.jsx)(n.code,{children:"form.values"})," can be used to get the current form values in controlled mode, it is\nrecommended to use ",(0,o.jsx)(n.code,{children:"form.getValues"})," instead as it always returns the latest\nvalues while ",(0,o.jsx)(n.code,{children:"form.values"})," is outdated in uncontrolled mode and before state\nupdate in controlled mode."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n});\n\nconst handleNameChange = () => {\n  form.setFieldValue('name', 'Test Name');\n\n  // ❌ Do not use form.values to get the current form values\n  // form.values has stale name value until next rerender in controlled mode\n  // and is always outdated in uncontrolled mode\n  console.log(form.values); // { name: 'John Doe' }\n\n  // ✅ Use form.getValues to get the current form values\n  // form.getValues always returns the latest form values\n  console.log(form.getValues()); // { name: 'Test Name' }\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"form.getValues()"})," returns a ref value of the current form values. This means that\nyou cannot pass it to ",(0,o.jsx)(n.code,{children:"useEffect"})," dependencies array as it will always be the same\nreference."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useEffect } from 'react';\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({ mode: 'uncontrolled' });\n\nuseEffect(() => {\n  // ❌ This will not work as form.getValues() is a ref value\n  // and will always be the same reference\n}, [form.getValues()]);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Instead of observing form values with ",(0,o.jsx)(n.code,{children:"useEffect"}),", use ",(0,o.jsx)(n.code,{children:"onValuesChange"})," callback\nto listen to form values changes:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n  onValuesChange: (values) => {\n    // ✅ This will be called on every form values change\n    console.log(values);\n  },\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"formgetinputprops",children:"form.getInputProps"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/form/get-input-props/",children:"form.getInputProps"})," returns different props for controlled\nand uncontrolled modes. In controlled mode, the returned object has ",(0,o.jsx)(n.code,{children:"value"})," prop,\nwhile in uncontrolled mode it has ",(0,o.jsx)(n.code,{children:"defaultValue"})," prop."]}),"\n",(0,o.jsxs)(n.p,{children:["Uncontrolled mode relies on ",(0,o.jsx)(n.code,{children:"key"})," returned from ",(0,o.jsx)(n.code,{children:"form.key()"})," to update\ncomponents when ",(0,o.jsx)(n.code,{children:"form.setFieldValue"})," or ",(0,o.jsx)(n.code,{children:"form.setValues"})," are called. You should\nset ",(0,o.jsx)(n.code,{children:"key"})," supplied by ",(0,o.jsx)(n.code,{children:"form.key()"})," to the input component to ensure that it has\nupdated value:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: { text: '' },\n  });\n\n  return (\n    <input {...form.getInputProps('text')} key={form.key('text')} />\n  );\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In case you need to have a ",(0,o.jsx)(n.a,{href:"/form/nested/#nested-arrays",children:"list of fields"}),",\ndo not pass ",(0,o.jsx)(n.code,{children:"key"})," to the input component directly, instead add a wrapper\nelement and pass ",(0,o.jsx)(n.code,{children:"key"})," to it:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useForm } from '@mantine/form';\nimport { randomId } from '@mantine/hooks';\n\n// ❌ Incorrect: Do not override key prop, even in lists\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      jobs: [{ company: 'Google' }, { company: 'Facebook' }],\n    },\n  });\n\n  const fields = form.getValues().jobs.map((_, index) => (\n      <input\n        {...form.getInputProps(`jobs.${index}.company`)}\n        key={index}\n      />\n    ));\n\n  return <form>{fields}</form>;\n}\n\n// ✅ Correct: Add wrapper element and pass key to it\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      jobs: [\n        { company: 'Google', key: randomId() },\n        { company: 'Facebook', key: randomId() },\n      ],\n    },\n  });\n\n  const fields = form.getValues().jobs.map((item, index) => (\n      <div key={item.key}>\n        <input\n          {...form.getInputProps(`jobs.${index}.company`)}\n          key={form.key(`jobs.${index}.company`)}\n        />\n      </div>\n    ));\n\n  return <form>{fields}</form>;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"uncontrolled-mode-in-custom-components",children:"Uncontrolled mode in custom components"}),"\n",(0,o.jsxs)(n.p,{children:["If you want to build a custom component that supports uncontrolled form mode,\nyou must add support for ",(0,o.jsx)(n.code,{children:"defaultValue"})," prop. The best way to add support for\n",(0,o.jsx)(n.code,{children:"defaultValue"})," is to use ",(0,o.jsx)(n.a,{href:"/hooks/use-uncontrolled/",children:"use-uncontrolled"})," hook:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useUncontrolled } from '@mantine/hooks';\n\ninterface CustomInputProps {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n}\n\n// ✅ CustomInput supports both controlled and uncontrolled modes\nfunction CustomInput({\n  value,\n  defaultValue,\n  onChange,\n}: CustomInputProps) {\n  const [_value, handleChange] = useUncontrolled({\n    value,\n    defaultValue,\n    finalValue: 'Final',\n    onChange,\n  });\n\n  return (\n    <input\n      type=\"text\"\n      value={_value}\n      onChange={(event) => handleChange(event.currentTarget.value)}\n    />\n  );\n}\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: { text: 'Initial' },\n  });\n\n  // ✅ CustomInput supports `defaultValue` prop,\n  // it can be used in uncontrolled mode\n  return (\n    <CustomInput\n      {...form.getInputProps('text')}\n      key={form.key('text')}\n    />\n  );\n}\n"})})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,o.jsx)(g,{...e,children:(0,o.jsx)(b,{...e})})}},74015:(e,n,t)=>{"use strict";function o(e,n,t){"object"==typeof t.value&&(t.value=r(t.value)),t.enumerable&&!t.get&&!t.set&&t.configurable&&t.writable&&"__proto__"!==n?e[n]=t.value:Object.defineProperty(e,n,t)}function r(e){if("object"!=typeof e)return e;var n,t,l,a=0,s=Object.prototype.toString.call(e);if("[object Object]"===s?l=Object.create(e.__proto__||null):"[object Array]"===s?l=Array(e.length):"[object Set]"===s?(l=new Set,e.forEach(function(e){l.add(r(e))})):"[object Map]"===s?(l=new Map,e.forEach(function(e,n){l.set(r(n),r(e))})):"[object Date]"===s?l=new Date(+e):"[object RegExp]"===s?l=new RegExp(e.source,e.flags):"[object DataView]"===s?l=new e.constructor(r(e.buffer)):"[object ArrayBuffer]"===s?l=e.slice(0):"Array]"===s.slice(-6)&&(l=new e.constructor(e)),l){for(t=Object.getOwnPropertySymbols(e);a<t.length;a++)o(l,t[a],Object.getOwnPropertyDescriptor(e,t[a]));for(a=0,t=Object.getOwnPropertyNames(e);a<t.length;a++)Object.hasOwnProperty.call(l,n=t[a])&&l[n]===e[n]||o(l,n,Object.getOwnPropertyDescriptor(e,n))}return l||e}t.d(n,{Q:()=>r})},28675:(e,n,t)=>{"use strict";t.d(n,{U:()=>c});var o=t(31085),r=t(14041),l=t(90275),a=t(52022),s=t(93065),m=t(37905),u=t(23719),i=t(41871),d=t(28887);let c={type:"code",component:function(){let e=(0,u.m)({mode:"uncontrolled",initialValues:{name:"",email:""},validate:{name:(0,i.J)({min:3},"Must be at least 3 characters"),email:(0,d.x)("Invalid email")}}),[n,t]=(0,r.useState)(null);return(0,o.jsxs)("form",{onSubmit:e.onSubmit(t),children:[(0,r.createElement)(l.k,{...e.getInputProps("name"),key:e.key("name"),label:"Name",placeholder:"Name"}),(0,r.createElement)(l.k,{...e.getInputProps("email"),key:e.key("email"),mt:"md",label:"Email",placeholder:"Email"}),(0,o.jsx)(a.$,{type:"submit",mt:"md",children:"Submit"}),(0,o.jsx)(s.E,{mt:"md",children:"Form values:"}),(0,o.jsx)(m.C,{block:!0,children:JSON.stringify(e.values,null,2)}),(0,o.jsx)(s.E,{mt:"md",children:"Submitted values:"}),(0,o.jsx)(m.C,{block:!0,children:n?JSON.stringify(n,null,2):"–"})]})},code:`
import { useState } from 'react';
import { Button, Code, Text, TextInput } from '@mantine/core';
import { hasLength, isEmail, useForm } from '@mantine/form';

function Demo() {
  const form = useForm({
    mode: 'uncontrolled',
    initialValues: { name: '', email: '' },
    validate: {
      name: hasLength({ min: 3 }, 'Must be at least 3 characters'),
      email: isEmail('Invalid email'),
    },
  });

  const [submittedValues, setSubmittedValues] = useState<typeof form.values | null>(null);

  return (
    <form onSubmit={form.onSubmit(setSubmittedValues)}>
      <TextInput
        {...form.getInputProps('name')}
        key={form.key('name')}
        label="Name"
        placeholder="Name"
      />
      <TextInput
        {...form.getInputProps('email')}
        key={form.key('email')}
        mt="md"
        label="Email"
        placeholder="Email"
      />
      <Button type="submit" mt="md">
        Submit
      </Button>

      <Text mt="md">Form values:</Text>
      <Code block>{JSON.stringify(form.values, null, 2)}</Code>

      <Text mt="md">Submitted values:</Text>
      <Code block>{submittedValues ? JSON.stringify(submittedValues, null, 2) : '\u2013'}</Code>
    </form>
  );
}
`,maxWidth:500,centered:!0,defaultExpanded:!1}},41871:(e,n,t)=>{"use strict";function o(e,n){if("number"==typeof e)return n.length===e;let{max:t,min:o}=e,r=!0;return"number"==typeof t&&n.length>t&&(r=!1),"number"==typeof o&&n.length<o&&(r=!1),r}function r(e,n){let t=n||!0;return n=>"string"==typeof n?o(e,n.trim())?null:t:"object"==typeof n&&null!==n&&"length"in n&&o(e,n)?null:t}t.d(n,{J:()=>r})},28887:(e,n,t)=>{"use strict";t.d(n,{x:()=>r});var o=t(27351);function r(e){return(0,o.c)(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,e)}},27351:(e,n,t)=>{"use strict";function o(e,n){let t=n||!0;return n=>"string"!=typeof n?t:e.test(n)?null:t}t.d(n,{c:()=>o})}},e=>{var n=n=>e(e.s=n);e.O(0,[67456,39699,68831,23719,90636,46593,38792],()=>n(36317)),_N_E=e.O()}]);