[View changelog with demos on mantine.dev website](https://mantine.dev/changelog/9-0-0)

## Support Mantine development

You can now sponsor Mantine development with [OpenCollective](https://opencollective.com/mantinedev).
All funds are used to improve Mantine and create new features and components.

## Migration guide

This changelog covers breaking changes and new features in Mantine 9.0.
To migrate your application to Mantine 9.0, follow [8.x → 9.x migration guide](https://mantine.dev/guides/8x-to-9x).

## Peer dependencies requirements updates

Starting from Mantine 9.0, the following dependencies are required:

- React 19+ for all `@mantine/*` packages
- Tiptap 3+ for `@mantine/tiptap` ([migration guide](https://mantine.dev/guides/tiptap-3-migration))
- Recharts 3+ for `@mantine/charts` (no migration required)

## Namespace types exports

All Mantine components and hooks now provide namespace exports for related types.
For example, [use-disclosure](https://mantine.dev/hooks/use-disclosure) hook types can now be accessed like this:

```tsx
import { useDisclosure } from '@mantine/hooks';

const options: useDisclosure.Options = {
  onOpen: () => console.log('open'),
  onClose: () => console.log('close'),
};

function Demo() {
  const [opened, handlers] = useDisclosure(options);
}
```

Example of using namespace types with [Button](https://mantine.dev/core/button) props type:

```tsx
import { Button } from '@mantine/core';

const buttonProps: Button.Props = {
    variant: 'filled',
    size: 'md',
    disabled: false,
  };

function Demo() {
  return <Button {...buttonProps}>Click me</Button>;
}
```

## Collapse horizontal orientation

[Collapse](https://mantine.dev/core/collapse) component now supports horizontal orientation:

```tsx
import { Button, Collapse, Stack, Typography } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';

function Demo() {
  const [expanded, handlers] = useDisclosure(false);

  return (
    <Stack h={240} align="flex-start">
      <Button onClick={handlers.toggle} w="fit-content">
        {expanded ? 'Collapse' : 'Expand'}
      </Button>

      <Collapse expanded={expanded} orientation="horizontal">
        <Typography bg="var(--mantine-color-blue-light)" p="xs" bdrs="md" w={200}>
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
          ut labore et dolore magna aliqua.
        </Typography>
      </Collapse>
    </Stack>
  );
}
```

## use-collapse and use-horizontal-collapse hooks

New `use-collapse` hook is the hook version of [Collapse](https://mantine.dev/core/collapse) component.
It allows animation of height from `0` to `auto` and vice versa.

```tsx
import { Button, Typography } from '@mantine/core';
import { useCollapse, useDisclosure } from '@mantine/hooks';

function Demo() {
  const [expanded, handlers] = useDisclosure(false);
  const getCollapseProps = useCollapse({ expanded });

  return (
    <>
      <Button onClick={handlers.toggle} mb="md">
        {expanded ? 'Collapse' : 'Expand'}
      </Button>

      <div {...getCollapseProps()}>
        <Typography bg="var(--mantine-color-blue-light)" p="xs" bdrs="md">
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
          ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
          ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </Typography>
      </div>
    </>
  );
}
```

`use-horizontal-collapse` works the same way as `use-collapse` but animates width instead of height:

```tsx
import { Button, Stack, Typography } from '@mantine/core';
import { useDisclosure, useHorizontalCollapse } from '@mantine/hooks';

function Demo() {
  const [expanded, handlers] = useDisclosure(false);
  const { getCollapseProps } = useHorizontalCollapse({ expanded });

  return (
    <Stack h={240}>
      <Button onClick={handlers.toggle} w="fit-content">
        {expanded ? 'Collapse' : 'Expand'}
      </Button>

      <div {...getCollapseProps()}>
        <Typography bg="var(--mantine-color-blue-light)" p="xs" bdrs="md" w={200}>
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
          ut labore et dolore magna aliqua.
        </Typography>
      </div>
    </Stack>
  );
}
```

## use-floating-window hook

New [use-floating-window](https://mantine.dev/hooks/use-floating-window) hook allows creating floating draggable
elements:

```tsx
import { Button, CloseButton, Group, Paper, Portal, Text } from '@mantine/core';
import { useDisclosure, useFloatingWindow } from '@mantine/hooks';

function Demo() {
  const [visible, handlers] = useDisclosure();
  const floatingWindow = useFloatingWindow({
    constrainToViewport: true,
    constrainOffset: 20,
    excludeDragHandleSelector: 'button',
    initialPosition: { top: 300, left: 20 },
  });

  return (
    <>
      <Button onClick={handlers.toggle} variant="default">
        {visible ? 'Hide' : 'Show'} floating window
      </Button>

      {visible && (
        <Portal>
          <Paper
            w={280}
            p="md"
            withBorder
            radius="md"
            pos="fixed"
            style={{ cursor: 'move', transition: 'box-shadow 70ms ease', zIndex: 400 }}
            shadow={floatingWindow.isDragging ? 'md' : undefined}
            ref={floatingWindow.ref}
          >
            <Group justify="space-between" mb="md">
              <Text>Usage demo</Text>
              <CloseButton onClick={handlers.close} />
            </Group>
            <Text fz="sm">This is a floating window. You can drag it around.</Text>
          </Paper>
        </Portal>
      )}
    </>
  );
}
```

## FloatingWindow component

[FloatingWindow](https://mantine.dev/core/floating-window) provides component API for [use-floating-window](https://mantine.dev/hooks/use-floating-window) hook:

```tsx
import { Button, CloseButton, FloatingWindow, Group, Text } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';

function Demo() {
  const [visible, handlers] = useDisclosure();

  return (
    <>
      <Button onClick={handlers.toggle} variant="default">
        {visible ? 'Hide' : 'Show'} floating window
      </Button>

      {visible && (
        <FloatingWindow
          w={280}
          p="md"
          withBorder
          radius="md"
          excludeDragHandleSelector="button"
          initialPosition={{ top: 300, left: 20 }}
          style={{ cursor: 'move' }}
        >
          <Group justify="space-between" mb="md">
            <Text>Usage demo</Text>
            <CloseButton onClick={handlers.close} />
          </Group>
          <Text fz="sm">This is a floating window. You can drag it around.</Text>
        </FloatingWindow>
      )}
    </>
  );
}
```

## OverflowList component

New [OverflowList](https://mantine.dev/core/overflow-list) component displays list of items and collapses the overflowing items into a single element:

```tsx
// OverflowListDemo.tsx
import { Badge, OverflowList } from '@mantine/core';
import { data } from './data';

function Demo() {
  return (
    <div style={{ resize: 'horizontal', overflow: 'auto', maxWidth: '100%' }}>
      <OverflowList
        data={data}
        gap={4}
        renderOverflow={(items) => <Badge>+{items.length} more</Badge>}
        renderItem={(item, index) => <Badge key={index}>{item}</Badge>}
      />
    </div>
  );
}

// data.ts
export const data = [
  'Apple',
  'Banana',
  'Cherry',
  'Date',
  'Elderberry',
  'Fig',
  'Grape',
  'Honeydew',
  'Indian Fig',
  'Jackfruit',
  'Kiwi',
  'Lemon',
  'Mango',
  'Nectarine',
  'Orange',
  'Papaya',
];
```

## Card horizontal orientation

[Card](https://mantine.dev/core/card) component now supports horizontal orientation:

```tsx
import { Box, Card, Group, RingProgress, Text } from '@mantine/core';

const completed = 1887;
const total = 2334;
const stats = [
  { value: 447, label: 'Remaining' },
  { value: 76, label: 'In progress' },
];

function Demo() {
  const items = stats.map((stat) => (
    <div key={stat.label}>
      <Text>{stat.value}</Text>
      <Text size="xs" c="dimmed">
        {stat.label}
      </Text>
    </div>
  ));

  return (
    <Card padding="sm" radius="md" withBorder orientation="horizontal">
      <Card.Section inheritPadding px="xs" withBorder>
        <RingProgress
          roundCaps
          thickness={6}
          size={150}
          sections={[{ value: (completed / total) * 100, color: 'blue' }]}
          label={
            <div>
              <Text ta="center" fz="lg">
                {((completed / total) * 100).toFixed(0)}%
              </Text>
              <Text ta="center" fz="xs" c="dimmed">
                Completed
              </Text>
            </div>
          }
        />
      </Card.Section>

      <Card.Section inheritPadding px="md">
        <Text fz="xl">Project tasks</Text>
        <Box mt="xs">
          <Text>1887</Text>
          <Text fz="xs" c="dimmed">
            Completed
          </Text>
        </Box>

        <Group mt="sm">{items}</Group>
      </Card.Section>
    </Card>
  );
}
```

## Checkbox.Group and Switch.Group maxSelectedValues

[Checkbox.Group](https://mantine.dev/core/checkbox) and [Switch.Group](https://mantine.dev/core/switch) now support `maxSelectedValues` prop to limit the number of selected values.
When the limit is reached, the remaining controls are disabled and cannot be selected.

```tsx
import { Checkbox, Group } from '@mantine/core';

function Demo() {
  return (
    <Checkbox.Group defaultValue={['react']} maxSelectedValues={2}>
      <Group>
        <Checkbox value="react" label="React" />
        <Checkbox value="svelte" label="Svelte" />
        <Checkbox value="ng" label="Angular" />
        <Checkbox value="vue" label="Vue" />
      </Group>
    </Checkbox.Group>
  );
}
```

## Inputs loading state

All Mantine input components based on [Input](https://mantine.dev/core/input) component now support `loading` prop.

Set `loading` prop to display a loading indicator. By default, the loader is displayed on the right side of the input.
You can change the position with the `loadingPosition` prop to `'left'` or `'right'`. This is useful for async operations like API calls, searches, or validations:

```tsx
import { TextInput } from '@mantine/core';

function Demo() {
  return <TextInput placeholder="Your email" loading />;
}
```

## renderPill in MultiSelect and TagsInput

[MultiSelect](https://mantine.dev/core/multi-select) and [TagsInput](https://mantine.dev/core/tags-input) components now support `renderPill` prop to customize pill rendering:

```tsx
import { MultiSelect, Pill, Avatar } from '@mantine/core';

const users = [
  { value: 'Emily Johnson', label: 'Emily Johnson', image: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-7.png' },
  { value: 'Ava Rodriguez', label: 'Ava Rodriguez', image: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-8.png' },
  { value: 'Olivia Chen', label: 'Olivia Chen', image: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-4.png' },
  { value: 'Ethan Barnes', label: 'Ethan Barnes', image: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-1.png' },
  { value: 'Mason Taylor', label: 'Mason Taylor', image: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-2.png' },
];

function Demo() {
  return (
    <MultiSelect
      data={users}
      label="Candidates"
      placeholder="Select candidates"
      defaultValue={['Emily Johnson', 'Ava Rodriguez']}
      renderPill={({ option, onRemove }) => {
        const user = users.find((u) => u.value === option?.value);
        return (
          <Pill withRemoveButton onRemove={onRemove}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <Avatar src={user?.image} size={16} />
              {option?.label}
            </div>
          </Pill>
        );
      }}
    />
  );
}
```

## Clear section mode

All clearable input components now support `clearSectionMode` prop that determines how the clear button and `rightSection` are rendered:

- `'both'` (default) – render both the clear button and `rightSection`
- `'rightSection'` – render only the user-supplied `rightSection`, ignore clear button
- `'clear'` – render only the clear button, ignore `rightSection`

This prop is supported by [Select](https://mantine.dev/core/select), [Autocomplete](https://mantine.dev/core/autocomplete),
[MultiSelect](https://mantine.dev/core/multi-select), [TagsInput](https://mantine.dev/core/tags-input), [FileInput](https://mantine.dev/core/file-input),
[DateInput](https://mantine.dev/dates/date-input), [DatePickerInput](https://mantine.dev/dates/date-picker-input),
[MonthPickerInput](https://mantine.dev/dates/month-picker-input), [YearPickerInput](https://mantine.dev/dates/year-picker-input),
[TimePicker](https://mantine.dev/dates/time-picker), and [DateTimePicker](https://mantine.dev/dates/date-time-picker).

```tsx
import { IconChevronDown } from '@tabler/icons-react';
import { Stack } from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';

function Demo() {
  return (
    <Stack>
      <DatePickerInput
        label="clearSectionMode='both' (default)"
        placeholder="Pick date"
        defaultValue={new Date()}
        clearable
        rightSection={<IconChevronDown size={16} />}
        clearSectionMode="both"
      />

      <DatePickerInput
        label="clearSectionMode='rightSection'"
        placeholder="Pick date"
        defaultValue={new Date()}
        clearable
        rightSection={<IconChevronDown size={16} />}
        clearSectionMode="rightSection"
      />

      <DatePickerInput
        label="clearSectionMode='clear'"
        placeholder="Pick date"
        defaultValue={new Date()}
        clearable
        rightSection={<IconChevronDown size={16} />}
        clearSectionMode="clear"
      />
    </Stack>
  );
}
```

## Marquee component

New [Marquee](https://mantine.dev/core/marquee) component creates continuous scrolling animation for content:

```tsx
import { Marquee } from '@mantine/core';
import { MantineLogo } from '@mantinex/mantine-logo';

function Demo() {
  return (
    <Marquee gap="lg">
      <MantineLogo width={80} type="full" color="blue" />
      <MantineLogo width={80} type="full" color="cyan" />
      <MantineLogo width={80} type="full" color="teal" />
      <MantineLogo width={80} type="full" color="green" />
      <MantineLogo width={80} type="full" color="lime" />
      <MantineLogo width={80} type="full" color="yellow" />
      <MantineLogo width={80} type="full" color="orange" />
      <MantineLogo width={80} type="full" color="red" />
    </Marquee>
  );
}
```

## Scroller component

New [Scroller](https://mantine.dev/core/scroller) component displays horizontally scrollable content with navigation controls.
It supports native scrolling via trackpad, shift + mouse wheel, touch gestures, and mouse drag:

```tsx
import { Badge, Group, Scroller } from '@mantine/core';

function Demo() {
  return (
    <Scroller>
      <Group gap="xs" wrap="nowrap">
        {Array.from({ length: 20 }).map((_, index) => (
          <Badge key={index} variant="light" size="lg">
            Badge {index + 1}
          </Badge>
        ))}
      </Group>
    </Scroller>
  );
}
```

## use-scroller hook

New [use-scroller](https://mantine.dev/hooks/use-scroller) hook provides logic for creating custom scrollable containers with navigation controls:

```tsx
import { Box, Button, Group } from '@mantine/core';
import { useScroller } from '@mantine/hooks';

function Demo() {
  const scroller = useScroller();

  return (
    <Box>
      <Group mb="md">
        <Button
          onClick={scroller.scrollStart}
          disabled={!scroller.canScrollStart}
          variant="default"
          size="xs"
        >
          ← Scroll left
        </Button>
        <Button
          onClick={scroller.scrollEnd}
          disabled={!scroller.canScrollEnd}
          variant="default"
          size="xs"
        >
          Scroll right →
        </Button>
      </Group>

      <div
        ref={scroller.ref}
        {...scroller.dragHandlers}
        style={{
          overflow: 'auto',
          cursor: scroller.isDragging ? 'grabbing' : 'grab',
        }}
      >
        <Group wrap="nowrap" gap="md">
          {Array.from({ length: 20 }).map((_, index) => (
            <Box
              key={index}
              style={{
                minWidth: 100,
                height: 80,
                backgroundColor: 'var(--mantine-color-blue-filled)',
                borderRadius: 'var(--mantine-radius-md)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: 'white',
                fontWeight: 500,
              }}
            >
              {index + 1}
            </Box>
          ))}
        </Group>
      </div>
    </Box>
  );
}
```

## use-form TransformedValues type argument

[use-form](https://mantine.dev/form/use-form) now supports passing second type argument `TransformedValues` to define the type of
transformed values returned by `form.getTransformedValues` and `form.onSubmit`:

```tsx
import { useForm } from '@mantine/form';

interface FormValues {
  name: string;
  locationId: string;
}

interface TransformedValues {
  name: string;
  locationId: number;
}

function Demo() {
  const form = useForm<FormValues, TransformedValues>({
    mode: 'uncontrolled',
    initialValues: {
      name: '',
      locationId: '2',
    },

    transformValues: (values) => ({
      ...values,
      locationId: Number(values.locationId),
    }),
  });
}
```

## Generic components

[SegmentedControl](https://mantine.dev/core/segmented-control), [Select](https://mantine.dev/core/select), [MultiSelect](https://mantine.dev/core/multi-select),
[Chip.Group](https://mantine.dev/core/chip), [Switch.Group](https://mantine.dev/core/switch), [Checkbox.Group](https://mantine.dev/core/checkbox) and [Radio.Group](https://mantine.dev/core/radio)
now support generic value type. You can pass primitive values (numbers, strings, boolean, null)
as the type argument. The generic type is used for `value`, `defaultValue`, `onChange` and other props.

For example, generic type can now be used with [SegmentedControl](https://mantine.dev/core/segmented-control)
to specify string union:

```tsx
import { SegmentedControl } from '@mantine/core';

function Demo() {
  return (
    <SegmentedControl<'orange' | 'grape' | 'apple'>
      data={[
        { value: 'orange', label: 'Orange' },
        { value: 'grape', label: 'Grape' },
        { value: 'apple', label: 'Apple' },
      ]}
    />
  );
}
```

## Combobox virtualization (alpha)

[Combobox](https://mantine.dev/core/combobox) component now supports [virtualization](https://mantine.dev/core/combobox/#virtualization).
Virtualization support is currently in alpha stage and the API may change in future releases. You
are welcome to try it out and provide feedback.

Example of implementation with `useVirtualizedCombobox` and [react-virtuoso](https://virtuoso.dev/):

```tsx
import { useRef, useState } from 'react';
import { ListRange, Virtuoso } from 'react-virtuoso';
import { Combobox, Input, InputBase, ScrollArea, useVirtualizedCombobox } from '@mantine/core';

const largeData = Array(10000)
  .fill(0)
  .map((_, index) => ({
    value: `value-${index}`,
    label: `Label ${index}`,
    id: `item-${index}`,
    disabled: false,
  }));

function Demo() {
  const [opened, setOpened] = useState(false);
  const [selectedOptionIndex, setSelectedOptionIndex] = useState(0);
  const [activeOptionIndex, setActiveOptionIndex] = useState(-1);
  const [value, setValue] = useState('');
  const virtuoso = useRef<any>(null);
  const viewportRef = useRef<HTMLDivElement>(null);
  const visibleRangeRef = useRef<ListRange>({
    startIndex: 0,
    endIndex: 0,
  });

  const scrollOptionIntoView = (index: number) => {
    setTimeout(() => {
      const isVisible =
        index >= visibleRangeRef.current.startIndex && index <= visibleRangeRef.current.endIndex;
      if (index !== -1 && !isVisible) {
        virtuoso.current.scrollToIndex({ index, align: 'end' });
      }
    }, 4);
  };

  const combobox = useVirtualizedCombobox({
    opened,
    onOpenedChange: setOpened,
    onDropdownOpen: () => {
      if (activeOptionIndex !== -1) {
        combobox.selectActiveOption();
        scrollOptionIntoView(activeOptionIndex);
      }
    },
    isOptionDisabled: (index) => largeData[index].disabled,
    totalOptionsCount: largeData.length,
    getOptionId: (index) => largeData[index].id,
    selectedOptionIndex,
    activeOptionIndex,
    setSelectedOptionIndex: (index) => {
      setSelectedOptionIndex(index);
      scrollOptionIntoView(index);
    },
    onSelectedOptionSubmit: onOptionSubmit,
  });

  function onOptionSubmit(index: number) {
    const option = largeData[index];
    setValue(option.value);
    setActiveOptionIndex(index);
    combobox.closeDropdown();
    combobox.resetSelectedOption();
  }

  return (
    <Combobox
      store={combobox}
      resetSelectionOnOptionHover={false}
      keepMounted
      onOptionSubmit={(option) => {
        setValue(option);
        combobox.openDropdown();
      }}
    >
      <Combobox.Target>
        <InputBase component="button" onClick={() => combobox.toggleDropdown()} pointer>
          {value || <Input.Placeholder>Pick a value</Input.Placeholder>}
        </InputBase>
      </Combobox.Target>
      <Combobox.Dropdown>
        <Combobox.Options>
          <ScrollArea.Autosize
            mah={220}
            type="scroll"
            scrollbarSize={4}
            viewportRef={viewportRef}
            onMouseDown={(event) => event.preventDefault()}
          >
            <Virtuoso
              data={largeData}
              ref={virtuoso}
              style={{ height: 420 }}
              customScrollParent={viewportRef.current!}
              rangeChanged={(range) => {
                visibleRangeRef.current = range;
              }}
              itemContent={(index, item) => (
                <Combobox.Option
                  value={item.value}
                  key={item.value}
                  selected={index === selectedOptionIndex}
                  onClick={() => onOptionSubmit(index)}
                >
                  {item.label}
                </Combobox.Option>
              )}
            />
          </ScrollArea.Autosize>
        </Combobox.Options>
      </Combobox.Dropdown>
    </Combobox>
  );
}
```

## Highlight per-term colors

[Highlight](https://mantine.dev/core/highlight) component now supports custom colors for individual highlight terms.
You can provide an array of objects with `text` and `color` properties to assign different colors
to different highlighted terms:

```tsx
import { Highlight } from '@mantine/core';

function Demo() {
  return (
    <Highlight
      highlight={[
        { text: 'error', color: 'red' },
        { text: 'warning', color: 'yellow' },
        { text: 'success', color: 'green' },
      ]}
    >
      Error: Invalid input. Warning: Check this field. Success: All tests passed.
    </Highlight>
  );
}
```

## Highlight whole-word matching

[Highlight](https://mantine.dev/core/highlight) component now supports `wholeWord` prop to match only complete words.
When enabled, 'the' will not match 'there' or 'theme':

```tsx
import { Highlight, Stack, Text } from '@mantine/core';

function Demo() {
  return (
    <Stack gap="md">
      <div>
        <Text size="sm" fw={500} mb={5}>
          With whole word matching (wholeWord={'{'}true{'}'})
        </Text>
        <Highlight highlight="the" wholeWord>
          The theme is there
        </Highlight>
      </div>

      <div>
        <Text size="sm" fw={500} mb={5}>
          Without whole word matching (default)
        </Text>
        <Highlight highlight="the">The theme is there</Highlight>
      </div>
    </Stack>
  );
}
```

## Pagination and use-pagination startValue

[Pagination](https://mantine.dev/core/pagination) component and [use-pagination](https://mantine.dev/hooks/use-pagination) hook now support `startValue` prop
to define the starting page number. For example, with `startValue={5}` and `total={15}`,
the pagination range will be from 5 to 15:

```tsx
import { Text, Pagination } from '@mantine/core';

function Demo() {
  return (
    <>
      <Text mb="xs">Pages 5–15 (startValue=5, total=15)</Text>
      <Pagination total={15} startValue={5} defaultValue={5} />
    </>
  );
}
```

## Grid improvements

[Grid](https://mantine.dev/core/grid) component no longer uses negative margins for spacing between columns.
Instead, it now uses native CSS `gap` property, which means you no longer need to use
`overflow="hidden"` to prevent content overflow caused by negative margins.

## Slider vertical orientation

[Slider](https://mantine.dev/core/slider) and [RangeSlider](https://mantine.dev/core/slider) components now support vertical orientation:

```tsx
import { RangeSlider, Slider } from '@mantine/core';

const marks = [
  { value: 20, label: '20%' },
  { value: 50, label: '50%' },
  { value: 80, label: '80%' },
];

function Demo() {
  return (
    <div style={{ display: 'flex', gap: 40 }}>
      <Slider orientation="vertical" defaultValue={45} marks={marks} />
      <RangeSlider orientation="vertical" defaultValue={[25, 65]} marks={marks} />
    </div>
  );
}
```

## SimpleGrid improvements

[SimpleGrid](https://mantine.dev/core/simple-grid) component now supports `minColWidth` prop to use CSS Grid `auto-fill`/`auto-fit`
to automatically adjust the number of columns based on available space and minimum column width.
When `minColWidth` is set, the `cols` prop is ignored. Use `autoFlow` prop to switch between
`auto-fill` (default) and `auto-fit` behavior.

```tsx
import { SimpleGrid } from '@mantine/core';

function Demo() {
  return (
    <SimpleGrid minColWidth="200px">
      <div>1</div>
      <div>2</div>
      <div>3</div>
      <div>4</div>
      <div>5</div>
    </SimpleGrid>
  );
}
```

[SimpleGrid](https://mantine.dev/core/simple-grid) also now supports `autoRows` prop to control the size of
implicitly created grid rows:

```tsx
import { SimpleGrid } from '@mantine/core';

function Demo() {
  return (
    <SimpleGrid cols={3} autoRows="minmax(100px, auto)">
      <div>1</div>
      <div>2</div>
      <div>3</div>
      <div>4</div>
      <div>5</div>
    </SimpleGrid>
  );
}
```

## Documentation updates

- New [Custom components](https://mantine.dev/guides/custom-components) guide explaining how to create custom components with Mantine's styling system
- New [Controlled vs Uncontrolled](https://mantine.dev/guides/controlled-vs-uncontrolled) guide explaining differences between controlled and uncontrolled components
- [HueSlider](https://mantine.dev/core/hue-slider) and [AlphaSlider](https://mantine.dev/core/alpha-slider) components now have their own documentation pages
- Uncontrolled documentation and usage with `FormData` section was added to all inputs components
- [JsonInput](https://mantine.dev/core/json-input) documentation now includes custom serialization example with `superjson` library
- [Pagination](https://mantine.dev/core/pagination) documentation now includes URL synchronization examples for Next.js, react-router-dom and nuqs
- [use-form](https://mantine.dev/form/use-form) documentation now includes separate examples with [all Mantine inputs](https://mantine.dev/form/all-inputs)

## Other changes

- `light` variant in all components now uses different colors values without transparency to improve contrast
- `mod` prop now converts camelCase keys to kebab-case for data attributes in all components
- `@mantine/form` package no longer exports schema resolvers, use [dedicated packages](https://mantine.dev/form/schema-validation/) instead
- `createPolymorphicComponent` function was renamed to shorter `polymorphic` for convenience
- All Mantine components now use `font-weight: 600` instead of `font-weight: 500` for better readability
- All Mantine components now support logical margin and padding style props:
  - `mis` - margin-inline-start
  - `mie` - margin-inline-end
  - `pis` - padding-inline-start
  - `pie` - padding-inline-end
- [Tree](https://mantine.dev/core/tree) component now supports controlled state via `expandedState`, `selectedState` and `checkedState` props.
- [Tree](https://mantine.dev/core/tree) component no longer defines `data-hovered` attribute for hover state, you need to apply hover styles with `&:hover` instead. This change improves rendering performance by [resolving this issue](https://github.com/mantinedev/mantine/issues/7266).
- [Collapse](https://mantine.dev/core/collapse) component now uses `expanded` prop instead of `in`
- [Collapse](https://mantine.dev/core/collapse), [NavLink](https://mantine.dev/core/nav-link) and [Accordion.Panel](https://mantine.dev/core/accordion) now support `keepMounted={false}` prop to unmount collapsed content
- [Select](https://mantine.dev/core/select) and [MultiSelect](https://mantine.dev/core/multi-select) components now support primitive value types (numbers, booleans, strings) for data and value
- [MultiSelect](https://mantine.dev/core/multi-select) now supports `onMaxValues` prop, which is called when the user attempts to select more values than `maxValues`
- [TagsInput](https://mantine.dev/core/tags-input) component now supports `onMaxTags` prop, which is called when the user attempts to add more tags than `maxTags`
- [Accordion](https://mantine.dev/core/accordion) component now supports `ref` prop
- [Text](https://mantine.dev/core/text) and [Anchor](https://mantine.dev/core/anchor) components no longer accept `color` prop, use `c` style prop instead
- [PasswordInput](https://mantine.dev/core/password-input) component visibility toggle icon was updated
- [Popover](https://mantine.dev/core/popover) and [Tooltip](https://mantine.dev/core/tooltip) components no longer accept `positionDependencies` prop, it is no longer required
- [TypographyStylesProvider](https://mantine.dev/core/typography) component was renamed to [Typography](https://mantine.dev/core/typography)
- [Checkbox](https://mantine.dev/core/checkbox) component now supports `readOnly` and `withErrorStyles` props
- [Spoiler](https://mantine.dev/core/spoiler) component:
  - `initialState` prop was renamed to `defaultExpanded` for consistency with other components
  - New `showAriaLabel` and `hideAriaLabel` props allow customizing ARIA labels
- [Checkbox.Group](https://mantine.dev/core/checkbox/#checkboxgroup-with-formdata) and [Switch.Group](https://mantine.dev/core/switch/#switchgroup-with-formdata) can now be used in uncontrolled forms and can be accessed through `FormData`
- [ColorPicker](https://mantine.dev/core/color-picker) component now supports `name` and `hiddenInputProps` props to include color value in uncontrolled form submissions
- [Dialog](https://mantine.dev/core/dialog) now enables `withBorder` by default
- [Pagination](https://mantine.dev/core/pagination) component now supports `input-` prefix for `size` prop to match input and button sizes
- [FloatingIndicator](https://mantine.dev/core/floating-indicator) component now supports `onTransitionStart` and `onTransitionEnd` callbacks
- [LoadingOverlay](https://mantine.dev/core/loading-overlay) component now supports `onEnter`, `onEntered`, `onExit` and `onExited` callbacks
- [Grid](https://mantine.dev/core/grid) component `gutter` prop was renamed to `gap` for consistency with other layout components. New `rowGap` and `columnGap` props allow separate control of row and column spacing. [Grid.Col](https://mantine.dev/core/grid) now supports `align` prop for per-column vertical alignment.
- [Indicator](https://mantine.dev/core/indicator) component now supports:
  - `maxValue` prop to display `{maxValue}+` when the label exceeds the maximum value
  - `showZero` prop (default `true`) to control visibility of indicator with label `0`
  - `offset` prop object with `x` and `y` properties for separate horizontal and vertical offsets
- [NumberInput](https://mantine.dev/core/number-input) component now supports:
  - `onMinReached` and `onMaxReached` callbacks
  - `selectAllOnFocus` prop to select all text when input is focused
- [RingProgress](https://mantine.dev/core/ring-progress) component now supports
  - `sectionGap` prop to add visual separation between sections in degrees
  - `startAngle` prop to control where the progress starts (0 = right, 90 = bottom, 180 = left, 270 = top)
- [List](https://mantine.dev/core/list) component now supports HTML5 list attributes: `start`, `reversed`, and `value` props for enhanced semantic HTML support
- [JsonInput](https://mantine.dev/core/json-input) component now supports `indentSpaces` prop to control the number of spaces used for formatting JSON
- [Rating](https://mantine.dev/core/rating) component now supports `allowClear` prop to reset rating to 0 by clicking the same value
- [ScrollArea](https://mantine.dev/core/scroll-area) component now supports `onLeftReached` and `onRightReached` callbacks for horizontal scroll boundaries
- [Slider](https://mantine.dev/core/slider) and [RangeSlider](https://mantine.dev/core/range-slider) now support hidden marks with `hidden: true` property. Hidden marks allow snapping to specific values without displaying them visually, useful with `restrictToMarks` prop.
- [use-tree](https://mantine.dev/core/tree) no longer supports callback state setters for `setExpandedState`, `setSelectedState`, and `setCheckedState` functions
- [use-fullscreen](https://mantine.dev/hooks/use-fullscreen) hook was split into two hooks: `useFullscreenElement` and `useFullscreenDocument`
- [use-media-query](https://mantine.dev/hooks/use-media-query) hook no longer includes fallback for old Safari versions (iOS 13 and earlier, released before 2019)
- [use-resize-observer](https://mantine.dev/hooks/use-resize-observer) now uses the new callback ref approach. The new approach makes hook usable with dynamic node changes. This change might be breaking, validate hook usage in your application.
- [use-mouse](https://mantine.dev/hooks/use-mouse) hook now uses the new callback ref approach to resolve the issue with stale refs. The previous hook functionality was split into two hooks: `use-mouse` (for ref) and `use-mouse-position` (for document).
- [use-mutation-observer](https://mantine.dev/hooks/use-mutation-observer) hook now uses the new callback ref approach. The new approach makes hook usable with dynamic node changes. Additionally, a new `useMutationObserverTarget` hook was added for observing external target elements.
- [use-disclosure](https://mantine.dev/hooks/use-disclosure) hook now supports new `set` handler
- [use-floating-indicator](https://mantine.dev/hooks/use-floating-indicator) hook now supports `onTransitionStart` and `onTransitionEnd` callbacks
- `@mantine/hooks` types were renamed for consistency:
  - `UseScrollSpyReturnType` → `UseScrollSpyReturnValue`
  - `StateHistory` → `UseStateHistoryValue`
  - `OS` → `UseOSReturnValue`
