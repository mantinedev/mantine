---
group: 'mantine-core'
package: '@mantine/core'
title: SegmentedControl
order: 1
slug: /core/segmented-control/
category: 'inputs'
description: 'A linear set of two or more segments'
props: ['SegmentedControl']
import: "import { SegmentedControl } from '@mantine/core';"
source: 'mantine-core/src/SegmentedControl/SegmentedControl.tsx'
docs: 'core/SegmentedControl.mdx'
styles: ['SegmentedControl']
---

import { SegmentedControlDemos } from '@mantine/demos';

## Usage

<Demo data={SegmentedControlDemos.usage} />

## Controlled

```tsx
import { useState } from 'react';
import { SegmentedControl } from '@mantine/core';

function Demo() {
  const [value, setValue] = useState('react');
  return (
    <SegmentedControl
      value={value}
      onChange={setValue}
      data={[
        { label: 'React', value: 'react' },
        { label: 'Angular', value: 'ng' },
        { label: 'Vue', value: 'vue' },
        { label: 'Svelte', value: 'svelte' },
      ]}
    />
  );
}
```

## Data prop

SegmentedControl support two different data formats:

1. An array of strings – use when you do not need to customize item component or display `label` different than `value`
2. An array of objects with required `value` and `label` properties and any other additional properties

```tsx
// Data as an array of strings, will be mapped to
// [
//  { value: 'React', label: 'React' },
//  { value: 'Angular', label: 'Angular' },
//  { value: 'Svelte', label: 'Svelte' },
//  { value: 'Vue', label: 'Vue' },
// ]
<SegmentedControl data={['React', 'Angular', 'Svelte', 'Vue']} />

// Data as an array of objects:
<SegmentedControl data={[
  { value: 'React', label: 'React' },
  { value: 'Angular', label: 'Angular' },
  { value: 'Svelte', label: 'Svelte' },
  { value: 'Vue', label: 'Vue' },
]} />
```

## Disabled state

<Demo data={SegmentedControlDemos.disabled} />

## React node as label

<Demo data={SegmentedControlDemos.labels} />

## Full width and orientation

By default, SegmentedControl will take only the amount of space that is required to render elements.
Set `fullWidth` prop to make it block and take 100% width of its container.

<Demo data={SegmentedControlDemos.fullWidth} />

## Sizes

Component supports 5 sizes: xs, sm, md, lg, xl.
Size controls font-size and padding properties.

```tsx
<SegmentedControl size="sm" />
```

SegmentedControl sizes from xs to xl:

<Demo data={SegmentedControlDemos.sizes} />

## Radius

xs, sm, md, lg, xl radius values are defined in `theme.radius`. Alternatively, you can use any CSS value to set border-radius:

```tsx
<SegmentedControl radius="lg" /> // -> theme predefined large radius
<SegmentedControl radius={16} /> // -> { borderRadius: '1rem' }
<SegmentedControl radius={0} /> // -> { borderRadius: 0 }
```

Default theme radius values from xs to xl with lg size:

<Demo data={SegmentedControlDemos.radius} />

## Color

By default, segmented control uses `theme.white` with shadow in light color scheme and `theme.colors.dark[6]` background color for active element.
You can choose any color defined in `theme.colors` in case you need colored variant:

<Demo data={SegmentedControlDemos.configurator} />

## Transitions

Change transition properties with:

- **transitionDuration** – all transitions duration in ms (ignored if user prefers to reduce motion)
- **transitionTimingFunction** – defaults to `theme.transitionTimingFunction`

<Demo data={SegmentedControlDemos.transitions} />

## Accessibility and usability

SegmentedControl uses radio inputs under the hood, it is accessible by default with no extra steps required.
Component support the same keyboard events as a regular radio group.
