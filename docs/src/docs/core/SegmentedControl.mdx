---
group: 'mantine-core'
package: '@mantine/core'
title: SegmentedControl
order: 1
slug: /core/segmented-control/
category: 'inputs'
description: 'Horizontal control made of multiple segments, alternative to RadioGroup'
props: ['SegmentedControl']
import: "import { SegmentedControl } from '@mantine/core';"
source: 'mantine-core/src/components/SegmentedControl/SegmentedControl.tsx'
docs: 'core/SegmentedControl.mdx'
styles: ['SegmentedControl']
---

import { SegmentedControlDemos } from '@demos/core';

## Usage

SegmentedControl is usually used as an alternative to:

- [Tabs](/core/tabs/) to switch views
- [RadioGroup](/core/radio-group/) to capture user feedback limited to certain
  options

<Demo data={SegmentedControlDemos.usage} />

## Controlled

```tsx
import { useState } from 'react';
import { SegmentedControl } from '@mantine/core';

function Demo() {
  const [value, setValue] = useState('react');
  return (
    <SegmentedControl
      value={value}
      onChange={setValue}
      data={[
        { label: 'React', value: 'react' },
        { label: 'Angular', value: 'ng' },
        { label: 'Vue', value: 'vue' },
        { label: 'Svelte', value: 'svelte' },
      ]}
    />
  );
}
```

## Data prop

SegmentedControl support two different data formats:

1. An array of strings – use when you do not need to customize item component or display `label` different than `value`
2. An array of objects with required `value` and `label` properties and any other additional properties

```tsx
// Data as an array of strings, will be mapped to
// [
//  { value: 'React', label: 'React' },
//  { value: 'Angular', label: 'Angular' },
//  { value: 'Svelte', label: 'Svelte' },
//  { value: 'Vue', label: 'Vue' },
// ]
<SegmentedControl data={['React', 'Angular', 'Svelte', 'Vue']} />

// Data as an array of objects:
<SegmentedControl data={[
  { value: 'React', label: 'React' },
  { value: 'Angular', label: 'Angular' },
  { value: 'Svelte', label: 'Svelte' },
  { value: 'Vue', label: 'Vue' },
]} />
```

## React node as label

You can use any React node as label in `data` prop:

<Demo data={SegmentedControlDemos.labels} />

## Full width

By default SegmentedControl is inline and will take only the amount of space which is required to render elements.
Set `fullWidth` prop to make it block and take 100% width of its container:

<Demo data={SegmentedControlDemos.fullWidth} />

## Sizes

Component supports 5 sizes: xs, sm, md, lg, xl.
Size controls font-size and padding properties.

```tsx
<SegmentedControl size="sm" />
```

SegmentedControl sizes from xs to xl:

<Demo data={SegmentedControlDemos.sizes} />

## Radius

xs, sm, md, lg, xl radius values are defined in [theme.radius](/theming/extend-theme/#spacing-radius-and-shadows).
Alternatively, you can use a number to set radius in px:

```tsx
<SegmentedControl radius="lg" /> // -> theme predefined large radius
<SegmentedControl radius={20} /> // -> { borderRadius: '20px' }
<SegmentedControl radius={0} /> // -> { borderRadius: 0 }
```

Default theme radius values from xs to xl with lg size:

<Demo data={SegmentedControlDemos.radius} />

## Color

By default segmented control uses `theme.white` with shadow in light color scheme and `theme.colors.dark[6]` background color for active element.
You can choose any color defined in [theme.colors](/theming/extend-theme/#default-colors) in case you need colored variant:

<Demo data={SegmentedControlDemos.configurator} />

## Transitions

Change transition properties with:

- **transitionDuration** – all transitions duration in ms (ignored if user prefers to reduce motion)
- **transitionTimingFunction** – defaults to `theme.transitionTimingFunction`

<Demo data={SegmentedControlDemos.transitions} />

## Resize observer

SegmentedControl uses [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)
to calculate active control background position. Position changes on container width change with 50ms debounce to avoid performance issue.

ResizeObserver is [supported by all modern browsers](https://caniuse.com/resizeobserver),
if you encounter any errors with browser compatibility use [polyfill](https://www.npmjs.com/package/resize-observer-polyfill):

```tsx
import ResizeObserver from 'resize-observer-polyfill';
window.ResizeObserver = ResizeObserver;
```

## Accessibility and usability

SegmentedControl uses radio inputs under the hood, it is accessible by default with no extra steps required.
Component support the same keyboard events as regular radio group.

## TypeScript

### Component props type

Import component props type:

```tsx
import type { SegmentedControlProps } from '@mantine/core';
```

`SegmentedControlProps` extends `React.ComponentPropsWithoutRef<'div'>`, all other props are available under _Component props_ tab.

### SegmentedControlStylesNames type

`SegmentedControlStylesNames` type is a union with SegmentedControl [Styles API](/theming/styles-api/) names:

```tsx
import type { SegmentedControlStylesNames } from '@mantine/core';

const segmentedClasses: Partial<Record<SegmentedControlStylesNames, 'string'>> = {
  label: 'segmented-label',
  control: 'segmented-control',
};

<SegmentedControl classNames={segmentedClasses} />;
```

See full styles descriptions list under _Styles API_ tab.

### SegmentedControlItem type

`SegmentedControlItem` type lets you validate object items that will be passed to SegmentedControl `data` prop:

```tsx
import type { SegmentedControlItem } from '@mantine/core';

const autocompleteData: SegmentedControlItem[] = [
  { value: 'John', label: <div>John</div> },
  { value: 'Jake', label: <div>Jake</div> },
  { value: 'Amy', label: <div>Amy</div> },
];
```
